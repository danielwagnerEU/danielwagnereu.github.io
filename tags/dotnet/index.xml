<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dotnet on Daniel Wagner</title><link>https://danielwagner.at/tags/dotnet/</link><description>Recent content in dotnet on Daniel Wagner</description><generator>Hugo -- gohugo.io</generator><language>de-at</language><managingEditor>daniel@danielwagner.at (Daniel Wagner)</managingEditor><webMaster>daniel@danielwagner.at (Daniel Wagner)</webMaster><lastBuildDate>Fri, 10 Dec 2021 17:36:00 +0100</lastBuildDate><atom:link href="https://danielwagner.at/tags/dotnet/index.xml" rel="self" type="application/rss+xml"/><item><title>Advent of Code 2021 Day 10</title><link>https://danielwagner.at/posts/2021-12-10-aoc2021-day10/</link><pubDate>Fri, 10 Dec 2021 17:36:00 +0100</pubDate><author>daniel@danielwagner.at (Daniel Wagner)</author><guid>https://danielwagner.at/posts/2021-12-10-aoc2021-day10/</guid><description>The theme for today is:
Stack it, baby!
Puzzle One This reminded my of one of my university lectures on compiler construction. There we used different data structures, to efficiently store the parsed programs. Often there were trees, but the key to day 10 is the Stack 1. Accompanying I use Dictionary 2 to efficiently lookup of matching brackets and gained scores.
With these data structures prepared, a test if a pair of brackets is matching results in simple lookups:</description></item><item><title>Advent of Code 2021 Day 6</title><link>https://danielwagner.at/posts/2021-12-06-aoc2021-day6/</link><pubDate>Mon, 06 Dec 2021 17:36:00 +0100</pubDate><author>daniel@danielwagner.at (Daniel Wagner)</author><guid>https://danielwagner.at/posts/2021-12-06-aoc2021-day6/</guid><description>The theme for today is:
Sometimes looking up is better than searching
Puzzle One Think of clustering the lanternfish swarm into buckets of their current day of the creation cycle.
UseGroupBy() 1 followed by ToDictionary() 2 to compute the initial clustering:
1 IDictionary&amp;lt;int, long&amp;gt; swarm = input.GroupBy(d =&amp;gt; d).ToDictionary(i =&amp;gt; i.Key, i =&amp;gt; (long)i.Count()); Then you can computer the new clustering after an iteration by iterating over the buckets of your clustering and computing the new count of lanternfish and the new bucket(s).</description></item><item><title>Advent of Code 2021 Day 1</title><link>https://danielwagner.at/posts/2021-12-01-aoc2021-day1/</link><pubDate>Wed, 01 Dec 2021 22:00:00 +0100</pubDate><author>daniel@danielwagner.at (Daniel Wagner)</author><guid>https://danielwagner.at/posts/2021-12-01-aoc2021-day1/</guid><description>Like in the past, I&amp;rsquo;m participating in this years https://adventofcode.com.
First of let&amp;rsquo;s look at the template that can be used for each day:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // See https://aka.ms/new-console-template for more information Console.WriteLine(&amp;#34;AoC 2021 Day 1&amp;#34;); var input = (await File.ReadAllLinesAsync(&amp;#34;input.txt&amp;#34;)) .Select(line =&amp;gt; int.Parse(line)).ToArray(); Console.WriteLine($&amp;#34;One: {PuzzleOne(input)}&amp;#34;); Console.WriteLine($&amp;#34;Two: {PuzzleTwo(input)}&amp;#34;); int PuzzleOne(int[] input) { throw new NotImplementedException(); } int PuzzleTwo(int[] input) { throw new NotImplementedException(); } Puzzle One The idea of the code is to find a Linq expression which efficiently find&amp;rsquo;s pair&amp;rsquo;s &amp;ndash; an element and it&amp;rsquo;s predecessor &amp;ndash; which are compared.</description></item></channel></rss>